import{objectSpread2 as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Gradient as e}from"../gradient/Gradient.min.mjs";import{Group as i}from"../shapes/Group.min.mjs";import{FabricImage as s}from"../shapes/Image.min.mjs";import{classRegistry as r}from"../ClassRegistry.min.mjs";import{invertTransform as n,multiplyTransformMatrices as a,qrDecompose as o}from"../util/misc/matrix.min.mjs";import{removeTransformMatrixForSvgParsing as m}from"../util/transform_matrix_removal.min.mjs";import{Point as l}from"../Point.min.mjs";import{FILL as c,STROKE as p,CENTER as h}from"../constants.min.mjs";import{getGradientDefs as f}from"./getGradientDefs.min.mjs";import{getCSSRules as u}from"./getCSSRules.min.mjs";import{getTagName as g}from"./getTagName.min.mjs";import{parseTransformAttribute as P}from"./parseTransformAttribute.min.mjs";const d=t=>r.getSVGClass(g(t).toLowerCase());class j{constructor(t,e,i,s,r){this.elements=t,this.options=e,this.reviver=i,this.regexUrl=/^url\(['"]?#([^'"]+)['"]?\)/g,this.doc=s,this.clipPaths=r,this.gradientDefs=f(s),this.cssRules=u(s)}parse(){return Promise.all(this.elements.map((t=>this.createObject(t))))}async createObject(t){const e=d(t);if(e){const i=await e.fromElement(t,this.options,this.cssRules);return this.resolveGradient(i,t,c),this.resolveGradient(i,t,p),i instanceof s&&i._originalElement?m(i,i.parsePreserveAspectRatioAttribute()):m(i),await this.resolveClipPath(i,t),this.reviver&&this.reviver(t,i),i}return null}extractPropertyDefinition(t,e,i){const s=t[e],r=this.regexUrl;if(!r.test(s))return;r.lastIndex=0;const n=r.exec(s)[1];return r.lastIndex=0,i[n]}resolveGradient(i,s,r){const n=this.extractPropertyDefinition(i,r,this.gradientDefs);if(n){const a=s.getAttribute(r+"-opacity"),o=e.fromElement(n,i,t(t({},this.options),{},{opacity:a}));i.set(r,o)}}async resolveClipPath(t,e,s){const r=this.extractPropertyDefinition(t,"clipPath",this.clipPaths);if(r){const c=n(t.calcTransformMatrix()),p=r[0].parentElement;let f=e;for(;!s&&f.parentElement&&f.getAttribute("clip-path")!==t.clipPath;)f=f.parentElement;f.parentElement.appendChild(p);const u=P("".concat(f.getAttribute("transform")||""," ").concat(p.getAttribute("originalTransform")||""));p.setAttribute("transform","matrix(".concat(u.join(","),")"));const g=await Promise.all(r.map((t=>d(t).fromElement(t,this.options,this.cssRules).then((t=>(m(t),t.fillRule=t.clipRule,delete t.clipRule,t)))))),j=1===g.length?g[0]:new i(g),v=a(c,j.calcTransformMatrix());j.clipPath&&await this.resolveClipPath(j,f,p.getAttribute("clip-path")?f:void 0);const{scaleX:x,scaleY:b,angle:w,skewX:y,translateX:A,translateY:R}=o(v);j.set({flipX:!1,flipY:!1}),j.set({scaleX:x,scaleY:b,angle:w,skewX:y,skewY:0}),j.setPositionByOrigin(new l(A,R),h,h),t.clipPath=j}else delete t.clipPath}}export{j as ElementsParser};
//# sourceMappingURL=elements_parser.min.mjs.map
