{"version":3,"file":"Canvas.min.mjs","sources":["../../../src/canvas/Canvas.ts"],"sourcesContent":["import { classRegistry } from '../ClassRegistry';\nimport { NONE } from '../constants';\nimport type {\n  CanvasEvents,\n  DragEventData,\n  ObjectEvents,\n  TPointerEvent,\n  TPointerEventNames,\n  Transform,\n} from '../EventTypeDefs';\nimport { Point } from '../Point';\nimport type { ActiveSelection } from '../shapes/ActiveSelection';\nimport type { Group } from '../shapes/Group';\nimport type { IText } from '../shapes/IText/IText';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport { isTouchEvent, stopEvent } from '../util/dom_event';\nimport { getDocumentFromElement, getWindowFromElement } from '../util/dom_misc';\nimport { sendPointToPlane } from '../util/misc/planeChange';\nimport { isActiveSelection } from '../util/typeAssertions';\nimport type { CanvasOptions, TCanvasOptions } from './CanvasOptions';\nimport { SelectableCanvas } from './SelectableCanvas';\nimport { TextEditingManager } from './TextEditingManager';\n\nconst addEventOptions = { passive: false } as EventListenerOptions;\n\nconst getEventPoints = (canvas: Canvas, e: TPointerEvent) => {\n  const viewportPoint = canvas.getViewportPoint(e);\n  const scenePoint = canvas.getScenePoint(e);\n  return {\n    viewportPoint,\n    scenePoint,\n    pointer: viewportPoint,\n    absolutePointer: scenePoint,\n  };\n};\n\n// just to be clear, the utils are now deprecated and those are here exactly as minifier helpers\n// because el.addEventListener can't me be minified while a const yes and we use it 47 times in this file.\n// few bytes but why give it away.\nconst addListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['addEventListener']>\n) => el.addEventListener(...args);\nconst removeListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['removeEventListener']>\n) => el.removeEventListener(...args);\n\nconst syntheticEventConfig = {\n  mouse: {\n    in: 'over',\n    out: 'out',\n    targetIn: 'mouseover',\n    targetOut: 'mouseout',\n    canvasIn: 'mouse:over',\n    canvasOut: 'mouse:out',\n  },\n  drag: {\n    in: 'enter',\n    out: 'leave',\n    targetIn: 'dragenter',\n    targetOut: 'dragleave',\n    canvasIn: 'drag:enter',\n    canvasOut: 'drag:leave',\n  },\n} as const;\n\ntype TSyntheticEventContext = {\n  mouse: { e: TPointerEvent };\n  drag: DragEventData;\n};\n\nexport class Canvas extends SelectableCanvas implements CanvasOptions {\n  /**\n   * Contains the id of the touch event that owns the fabric transform\n   * @type Number\n   * @private\n   */\n  declare mainTouchId?: number;\n\n  declare enablePointerEvents: boolean;\n\n  /**\n   * Holds a reference to a setTimeout timer for event synchronization\n   * @type number\n   * @private\n   */\n  private declare _willAddMouseDown: number;\n\n  /**\n   * Holds a reference to an object on the canvas that is receiving the drag over event.\n   * @type FabricObject\n   * @private\n   */\n  private declare _draggedoverTarget?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas from where the drag operation started\n   * @type FabricObject\n   * @private\n   */\n  private declare _dragSource?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas that is the current drop target\n   * May differ from {@link _draggedoverTarget}\n   * @todo inspect whether {@link _draggedoverTarget} and {@link _dropTarget} should be merged somehow\n   * @type FabricObject\n   * @private\n   */\n  private declare _dropTarget: FabricObject<ObjectEvents> | undefined;\n\n  private _isClick: boolean;\n\n  textEditingManager = new TextEditingManager(this);\n\n  constructor(el?: string | HTMLCanvasElement, options: TCanvasOptions = {}) {\n    super(el, options);\n    // bind event handlers\n    (\n      [\n        '_onMouseDown',\n        '_onTouchStart',\n        '_onMouseMove',\n        '_onMouseUp',\n        '_onTouchEnd',\n        '_onResize',\n        // '_onGesture',\n        // '_onDrag',\n        // '_onShake',\n        // '_onLongPress',\n        // '_onOrientationChange',\n        '_onMouseWheel',\n        '_onMouseOut',\n        '_onMouseEnter',\n        '_onContextMenu',\n        '_onDoubleClick',\n        '_onDragStart',\n        '_onDragEnd',\n        '_onDragProgress',\n        '_onDragOver',\n        '_onDragEnter',\n        '_onDragLeave',\n        '_onDrop',\n      ] as (keyof this)[]\n    ).forEach((eventHandler) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n      this[eventHandler] = (this[eventHandler] as Function).bind(this);\n    });\n    // register event handlers\n    this.addOrRemove(addListener, 'add');\n  }\n\n  /**\n   * return an event prefix pointer or mouse.\n   * @private\n   */\n  private _getEventPrefix() {\n    return this.enablePointerEvents ? 'pointer' : 'mouse';\n  }\n\n  addOrRemove(functor: any, _eventjsFunctor: 'add' | 'remove') {\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    functor(getWindowFromElement(canvasElement), 'resize', this._onResize);\n    functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);\n    functor(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove,\n      addEventOptions,\n    );\n    functor(canvasElement, `${eventTypePrefix}out`, this._onMouseOut);\n    functor(canvasElement, `${eventTypePrefix}enter`, this._onMouseEnter);\n    functor(canvasElement, 'wheel', this._onMouseWheel);\n    functor(canvasElement, 'contextmenu', this._onContextMenu);\n    functor(canvasElement, 'dblclick', this._onDoubleClick);\n    functor(canvasElement, 'dragstart', this._onDragStart);\n    functor(canvasElement, 'dragend', this._onDragEnd);\n    functor(canvasElement, 'dragover', this._onDragOver);\n    functor(canvasElement, 'dragenter', this._onDragEnter);\n    functor(canvasElement, 'dragleave', this._onDragLeave);\n    functor(canvasElement, 'drop', this._onDrop);\n    if (!this.enablePointerEvents) {\n      functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);\n    }\n    // if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {\n    //   eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);\n    //   eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);\n    //   eventjs[eventjsFunctor](\n    //     canvasElement,\n    //     'orientation',\n    //     this._onOrientationChange\n    //   );\n    //   eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);\n    //   eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);\n    // }\n  }\n\n  /**\n   * Removes all event listeners, used when disposing the instance\n   */\n  removeListeners() {\n    this.addOrRemove(removeListener, 'remove');\n    // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      `${eventTypePrefix}up`,\n      this._onMouseUp as EventListener,\n    );\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      'touchmove',\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    clearTimeout(this._willAddMouseDown);\n  }\n\n  /**\n   * @private\n   * @param {Event} [e] Event object fired on wheel event\n   */\n  private _onMouseWheel(e: MouseEvent) {\n    this.__onMouseWheel(e);\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onMouseOut(e: TPointerEvent) {\n    const target = this._hoveredTarget;\n    const shared = {\n      e,\n      ...getEventPoints(this, e),\n    };\n    this.fire('mouse:out', { ...shared, target });\n    this._hoveredTarget = undefined;\n    target && target.fire('mouseout', { ...shared });\n    this._hoveredTargets.forEach((nestedTarget) => {\n      this.fire('mouse:out', { ...shared, target: nestedTarget });\n      nestedTarget && nestedTarget.fire('mouseout', { ...shared });\n    });\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseenter\n   */\n  private _onMouseEnter(e: TPointerEvent) {\n    // This find target and consequent 'mouse:over' is used to\n    // clear old instances on hovered target.\n    // calling findTarget has the side effect of killing target.__corner.\n    // as a short term fix we are not firing this if we are currently transforming.\n    // as a long term fix we need to separate the action of finding a target with the\n    // side effects we added to it.\n    if (!this._currentTransform && !this.findTarget(e)) {\n      this.fire('mouse:over', {\n        e,\n        ...getEventPoints(this, e),\n      });\n      this._hoveredTarget = undefined;\n      this._hoveredTargets = [];\n    }\n  }\n\n  /**\n   * supports native like text dragging\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragStart(e: DragEvent) {\n    this._isClick = false;\n    const activeObject = this.getActiveObject();\n    if (activeObject && activeObject.onDragStart(e)) {\n      this._dragSource = activeObject;\n      const options = { e, target: activeObject };\n      this.fire('dragstart', options);\n      activeObject.fire('dragstart', options);\n      addListener(\n        this.upperCanvasEl,\n        'drag',\n        this._onDragProgress as EventListener,\n      );\n      return;\n    }\n    stopEvent(e);\n  }\n\n  /**\n   * First we clear top context where the effects are being rendered.\n   * Then we render the effects.\n   * Doing so will render the correct effect for all cases including an overlap between `source` and `target`.\n   * @private\n   */\n  private _renderDragEffects(\n    e: DragEvent,\n    source?: FabricObject,\n    target?: FabricObject,\n  ) {\n    let dirty = false;\n    // clear top context\n    const dropTarget = this._dropTarget;\n    if (dropTarget && dropTarget !== source && dropTarget !== target) {\n      dropTarget.clearContextTop();\n      dirty = true;\n    }\n    source?.clearContextTop();\n    target !== source && target?.clearContextTop();\n    // render effects\n    const ctx = this.contextTop;\n    ctx.save();\n    ctx.transform(...this.viewportTransform);\n    if (source) {\n      ctx.save();\n      source.transform(ctx);\n      source.renderDragSourceEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    if (target) {\n      ctx.save();\n      target.transform(ctx);\n      target.renderDropTargetEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    ctx.restore();\n    dirty && (this.contextTopDirty = true);\n  }\n\n  /**\n   * supports native like text dragging\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#finishing_a_drag\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragEnd(e: DragEvent) {\n    const didDrop = !!e.dataTransfer && e.dataTransfer.dropEffect !== NONE,\n      dropTarget = didDrop ? this._activeObject : undefined,\n      options = {\n        e,\n        target: this._dragSource as FabricObject,\n        subTargets: this.targets,\n        dragSource: this._dragSource as FabricObject,\n        didDrop,\n        dropTarget: dropTarget as FabricObject,\n      };\n    removeListener(\n      this.upperCanvasEl,\n      'drag',\n      this._onDragProgress as EventListener,\n    );\n    this.fire('dragend', options);\n    this._dragSource && this._dragSource.fire('dragend', options);\n    delete this._dragSource;\n    // we need to call mouse up synthetically because the browser won't\n    this._onMouseUp(e);\n  }\n\n  /**\n   * fire `drag` event on canvas and drag source\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragProgress(e: DragEvent) {\n    const options = {\n      e,\n      target: this._dragSource as FabricObject | undefined,\n      dragSource: this._dragSource as FabricObject | undefined,\n      dropTarget: this._draggedoverTarget as FabricObject,\n    };\n    this.fire('drag', options);\n    this._dragSource && this._dragSource.fire('drag', options);\n  }\n\n  /**\n   * As opposed to {@link findTarget} we want the top most object to be returned w/o the active object cutting in line.\n   * Override at will\n   */\n  protected findDragTargets(e: DragEvent) {\n    this.targets = [];\n    const target = this._searchPossibleTargets(\n      this._objects,\n      this.getViewportPoint(e),\n    );\n    return {\n      target,\n      targets: [...this.targets],\n    };\n  }\n\n  /**\n   * prevent default to allow drop event to be fired\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#specifying_drop_targets\n   * @private\n   * @param {DragEvent} [e] Event object fired on Event.js shake\n   */\n  private _onDragOver(e: DragEvent) {\n    const eventType = 'dragover';\n    const { target, targets } = this.findDragTargets(e);\n    const dragSource = this._dragSource as FabricObject;\n    const options = {\n      e,\n      target,\n      subTargets: targets,\n      dragSource,\n      canDrop: false,\n      dropTarget: undefined,\n    };\n    let dropTarget;\n    //  fire on canvas\n    this.fire(eventType, options);\n    //  make sure we fire dragenter events before dragover\n    //  if dragleave is needed, object will not fire dragover so we don't need to trouble ourselves with it\n    this._fireEnterLeaveEvents(target, options);\n    if (target) {\n      if (target.canDrop(e)) {\n        dropTarget = target;\n      }\n      target.fire(eventType, options);\n    }\n    //  propagate the event to subtargets\n    for (let i = 0; i < targets.length; i++) {\n      const subTarget = targets[i];\n      // accept event only if previous targets didn't (the accepting target calls `preventDefault` to inform that the event is taken)\n      // TODO: verify if those should loop in inverse order then?\n      // what is the order of subtargets?\n      if (subTarget.canDrop(e)) {\n        dropTarget = subTarget;\n      }\n      subTarget.fire(eventType, options);\n    }\n    //  render drag effects now that relations between source and target is clear\n    this._renderDragEffects(e, dragSource, dropTarget);\n    this._dropTarget = dropTarget;\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragEnter(e: DragEvent) {\n    const { target, targets } = this.findDragTargets(e);\n    const options = {\n      e,\n      target,\n      subTargets: targets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragenter', options);\n    //  fire dragenter on targets\n    this._fireEnterLeaveEvents(target, options);\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragLeave(e: DragEvent) {\n    const options = {\n      e,\n      target: this._draggedoverTarget,\n      subTargets: this.targets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragleave', options);\n\n    //  fire dragleave on targets\n    this._fireEnterLeaveEvents(undefined, options);\n    this._renderDragEffects(e, this._dragSource);\n    this._dropTarget = undefined;\n    //  clear targets\n    this.targets = [];\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * `drop:before` is a an event that allows you to schedule logic\n   * before the `drop` event. Prefer `drop` event always, but if you need\n   * to run some drop-disabling logic on an event, since there is no way\n   * to handle event handlers ordering, use `drop:before`\n   * @private\n   * @param {Event} e\n   */\n  private _onDrop(e: DragEvent) {\n    const { target, targets } = this.findDragTargets(e);\n    const options = this._basicEventHandler('drop:before', {\n      e,\n      target,\n      subTargets: targets,\n      dragSource: this._dragSource,\n      ...getEventPoints(this, e),\n    });\n    //  will be set by the drop target\n    options.didDrop = false;\n    //  will be set by the drop target, used in case options.target refuses the drop\n    options.dropTarget = undefined;\n    //  fire `drop`\n    this._basicEventHandler('drop', options);\n    //  inform canvas of the drop\n    //  we do this because canvas was unaware of what happened at the time the `drop` event was fired on it\n    //  use for side effects\n    this.fire('drop:after', options);\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onContextMenu(e: TPointerEvent): false {\n    const target = this.findTarget(e),\n      subTargets = this.targets || [];\n    const options = this._basicEventHandler('contextmenu:before', {\n      e,\n      target,\n      subTargets,\n    });\n    // TODO: this line is silly because the dev can subscribe to the event and prevent it themselves\n    this.stopContextMenu && stopEvent(e);\n    this._basicEventHandler('contextmenu', options);\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onDoubleClick(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'dblclick');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Return a the id of an event.\n   * returns either the pointerId or the identifier or 0 for the mouse event\n   * @private\n   * @param {Event} evt Event object\n   */\n  getPointerId(evt: TouchEvent | PointerEvent): number {\n    const changedTouches = (evt as TouchEvent).changedTouches;\n\n    if (changedTouches) {\n      return changedTouches[0] && changedTouches[0].identifier;\n    }\n\n    if (this.enablePointerEvents) {\n      return (evt as PointerEvent).pointerId;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Determines if an event has the id of the event that is considered main\n   * @private\n   * @param {evt} event Event object\n   */\n  _isMainEvent(evt: TPointerEvent): boolean {\n    if ((evt as PointerEvent).isPrimary === true) {\n      return true;\n    }\n    if ((evt as PointerEvent).isPrimary === false) {\n      return false;\n    }\n    if (evt.type === 'touchend' && (evt as TouchEvent).touches.length === 0) {\n      return true;\n    }\n    if ((evt as TouchEvent).changedTouches) {\n      return (\n        (evt as TouchEvent).changedTouches[0].identifier === this.mainTouchId\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchStart(e: TouchEvent) {\n    // we will prevent scrolling if allowTouchScrolling is not enabled and\n    let shouldPreventScrolling = !this.allowTouchScrolling;\n    const currentActiveObject = this._activeObject;\n    if (this.mainTouchId === undefined) {\n      this.mainTouchId = this.getPointerId(e);\n    }\n    this.__onMouseDown(e);\n    // after executing fabric logic for mouse down let's see\n    // if we didn't change target or if we are drawing\n    // we want to prevent scrolling anyway\n    if (\n      this.isDrawingMode ||\n      (currentActiveObject && this._target === currentActiveObject)\n    ) {\n      shouldPreventScrolling = true;\n    }\n    // prevent default, will block scrolling from start\n    shouldPreventScrolling && e.preventDefault();\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    // if we scroll don't register the touch move event\n    shouldPreventScrolling &&\n      addListener(\n        doc,\n        'touchmove',\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n    // Unbind mousedown to prevent double triggers from touch devices\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}down`,\n      this._onMouseDown as EventListener,\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDown(e: TPointerEvent) {\n    this.__onMouseDown(e);\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(doc, `${eventTypePrefix}up`, this._onMouseUp as EventListener);\n    addListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchEnd(e: TouchEvent) {\n    if (e.touches.length > 0) {\n      // if there are still touches stop here\n      return;\n    }\n    this.__onMouseUp(e);\n    this._resetTransformEventData();\n    delete this.mainTouchId;\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      'touchmove',\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    if (this._willAddMouseDown) {\n      clearTimeout(this._willAddMouseDown);\n    }\n    this._willAddMouseDown = setTimeout(() => {\n      // Wait 400ms before rebinding mousedown to prevent double triggers\n      // from touch devices\n      addListener(\n        this.upperCanvasEl,\n        `${eventTypePrefix}down`,\n        this._onMouseDown as EventListener,\n      );\n      this._willAddMouseDown = 0;\n    }, 400) as unknown as number;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUp(e: TPointerEvent) {\n    this.__onMouseUp(e);\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    if (this._isMainEvent(e)) {\n      const doc = getDocumentFromElement(this.upperCanvasEl);\n      removeListener(\n        doc,\n        `${eventTypePrefix}up`,\n        this._onMouseUp as EventListener,\n      );\n      removeListener(\n        doc,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n      addListener(\n        canvasElement,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMove(e: TPointerEvent) {\n    const activeObject = this.getActiveObject();\n    !this.allowTouchScrolling &&\n      (!activeObject ||\n        // a drag event sequence is started by the active object flagging itself on mousedown / mousedown:before\n        // we must not prevent the event's default behavior in order for the window to start dragging\n        !activeObject.shouldStartDragging(e)) &&\n      e.preventDefault &&\n      e.preventDefault();\n    this.__onMouseMove(e);\n  }\n\n  /**\n   * @private\n   */\n  _onResize() {\n    this.calcOffset();\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n   * @private\n   * @param {Object} target\n   */\n  _shouldRender(target: FabricObject | undefined) {\n    const activeObject = this.getActiveObject();\n    // if just one of them is available or if they are both but are different objects\n    // this covers: switch of target, from target to no target, selection of target\n    // multiSelection with key and mouse\n    return (\n      !!activeObject !== !!target ||\n      (activeObject && target && activeObject !== target)\n    );\n  }\n\n  /**\n   * Method that defines the actions when mouse is released on canvas.\n   * The method resets the currentTransform parameters, store the image corner\n   * position in the image object and render the canvas on top.\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  __onMouseUp(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'up:before');\n\n    const transform = this._currentTransform;\n    const isClick = this._isClick;\n    const target = this._target;\n\n    // if right/middle click just fire events and return\n    // target undefined will make the _handleEvent search the target\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'up');\n      this._resetTransformEventData();\n      return;\n    }\n\n    if (this.isDrawingMode && this._isCurrentlyDrawing) {\n      this._onMouseUpInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n    let shouldRender = false;\n    if (transform) {\n      this._finalizeCurrentTransform(e);\n      shouldRender = transform.actionPerformed;\n    }\n    if (!isClick) {\n      const targetWasActive = target === this._activeObject;\n      this.handleSelection(e);\n      if (!shouldRender) {\n        shouldRender =\n          this._shouldRender(target) ||\n          (!targetWasActive && target === this._activeObject);\n      }\n    }\n    let pointer, corner;\n    if (target) {\n      const found = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      const { key, control } = found || {};\n      corner = key;\n      if (\n        target.selectable &&\n        target !== this._activeObject &&\n        target.activeOn === 'up'\n      ) {\n        this.setActiveObject(target, e);\n        shouldRender = true;\n      } else if (control) {\n        const mouseUpHandler = control.getMouseUpHandler(e, target, control);\n        if (mouseUpHandler) {\n          pointer = this.getScenePoint(e);\n          mouseUpHandler.call(control, e, transform!, pointer.x, pointer.y);\n        }\n      }\n      target.isMoving = false;\n    }\n    // if we are ending up a transform on a different control or a new object\n    // fire the original mouse up from the corner that started the transform\n    if (\n      transform &&\n      (transform.target !== target || transform.corner !== corner)\n    ) {\n      const originalControl =\n          transform.target && transform.target.controls[transform.corner],\n        originalMouseUpHandler =\n          originalControl &&\n          originalControl.getMouseUpHandler(\n            e,\n            transform.target,\n            originalControl,\n          );\n      pointer = pointer || this.getScenePoint(e);\n      originalMouseUpHandler &&\n        originalMouseUpHandler.call(\n          originalControl,\n          e,\n          transform,\n          pointer.x,\n          pointer.y,\n        );\n    }\n    this._setCursorFromEvent(e, target);\n    this._handleEvent(e, 'up');\n    this._groupSelector = null;\n    this._currentTransform = null;\n    // reset the target information about which corner is selected\n    target && (target.__corner = undefined);\n    if (shouldRender) {\n      this.requestRenderAll();\n    } else if (!isClick && !(this._activeObject as IText)?.isEditing) {\n      this.renderTop();\n    }\n  }\n\n  _basicEventHandler<T extends keyof (CanvasEvents | ObjectEvents)>(\n    eventType: T,\n    options: (CanvasEvents & ObjectEvents)[T],\n  ) {\n    const { target, subTargets = [] } = options as {\n      target?: FabricObject;\n      subTargets: FabricObject[];\n    };\n    this.fire(eventType, options);\n    target && target.fire(eventType, options);\n    for (let i = 0; i < subTargets.length; i++) {\n      subTargets[i] !== target && subTargets[i].fire(eventType, options);\n    }\n    return options;\n  }\n\n  /**\n   * @private\n   * Handle event firing for target and subtargets\n   * @param {TPointerEvent} e event from mouse\n   * @param {TPointerEventNames} eventType\n   */\n  _handleEvent<T extends TPointerEventNames>(e: TPointerEvent, eventType: T) {\n    const target = this._target,\n      targets = this.targets || [],\n      options: CanvasEvents[`mouse:${T}`] = {\n        e,\n        target,\n        subTargets: targets,\n        ...getEventPoints(this, e),\n        transform: this._currentTransform,\n        ...(eventType === 'up:before' || eventType === 'up'\n          ? {\n              isClick: this._isClick,\n              currentTarget: this.findTarget(e),\n              // set by the preceding `findTarget` call\n              currentSubTargets: this.targets,\n            }\n          : {}),\n      } as CanvasEvents[`mouse:${T}`];\n    this.fire(`mouse:${eventType}`, options);\n    // this may be a little be more complicated of what we want to handle\n    target && target.fire(`mouse${eventType}`, options);\n    for (let i = 0; i < targets.length; i++) {\n      targets[i] !== target && targets[i].fire(`mouse${eventType}`, options);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDownInDrawingMode(e: TPointerEvent) {\n    this._isCurrentlyDrawing = true;\n    if (this.getActiveObject()) {\n      this.discardActiveObject(e);\n      this.requestRenderAll();\n    }\n    // TODO: this is a scene point so it should be renamed\n    const pointer = this.getScenePoint(e);\n    this.freeDrawingBrush &&\n      this.freeDrawingBrush.onMouseDown(pointer, { e, pointer });\n    this._handleEvent(e, 'down');\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMoveInDrawingMode(e: TPointerEvent) {\n    if (this._isCurrentlyDrawing) {\n      const pointer = this.getScenePoint(e);\n      this.freeDrawingBrush &&\n        this.freeDrawingBrush.onMouseMove(pointer, {\n          e,\n          // this is an absolute pointer, the naming is wrong\n          pointer,\n        });\n    }\n    this.setCursor(this.freeDrawingCursor);\n    this._handleEvent(e, 'move');\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUpInDrawingMode(e: TPointerEvent) {\n    const pointer = this.getScenePoint(e);\n    if (this.freeDrawingBrush) {\n      this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({\n        e: e,\n        // this is an absolute pointer, the naming is wrong\n        pointer,\n      });\n    } else {\n      this._isCurrentlyDrawing = false;\n    }\n    this._handleEvent(e, 'up');\n  }\n\n  /**\n   * Method that defines the actions when mouse is clicked on canvas.\n   * The method inits the currentTransform parameters and renders all the\n   * canvas so the current image can be placed on the top canvas and the rest\n   * in on the container one.\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  __onMouseDown(e: TPointerEvent) {\n    this._isClick = true;\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'down:before');\n\n    let target: FabricObject | undefined = this._target;\n\n    // if right/middle click just fire events\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'down');\n      this._resetTransformEventData();\n      return;\n    }\n\n    if (this.isDrawingMode) {\n      this._onMouseDownInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    // ignore if some object is being transformed at this moment\n    if (this._currentTransform) {\n      return;\n    }\n\n    let shouldRender = this._shouldRender(target);\n    let grouped = false;\n    if (this.handleMultiSelection(e, target)) {\n      // active object might have changed while grouping\n      target = this._activeObject;\n      grouped = true;\n      shouldRender = true;\n    } else if (this._shouldClearSelection(e, target)) {\n      this.discardActiveObject(e);\n    }\n    // we start a group selector rectangle if\n    // selection is enabled\n    // and there is no target, or the following 3 conditions are satisfied:\n    // target is not selectable ( otherwise we selected it )\n    // target is not editing\n    // target is not already selected ( otherwise we drag )\n    if (\n      this.selection &&\n      (!target ||\n        (!target.selectable &&\n          !(target as IText).isEditing &&\n          target !== this._activeObject))\n    ) {\n      const p = this.getScenePoint(e);\n      this._groupSelector = {\n        x: p.x,\n        y: p.y,\n        deltaY: 0,\n        deltaX: 0,\n      };\n    }\n\n    if (target) {\n      const alreadySelected = target === this._activeObject;\n      if (target.selectable && target.activeOn === 'down') {\n        this.setActiveObject(target, e);\n      }\n      const handle = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      if (target === this._activeObject && (handle || !grouped)) {\n        this._setupCurrentTransform(e, target, alreadySelected);\n        const control = handle ? handle.control : undefined,\n          pointer = this.getScenePoint(e),\n          mouseDownHandler =\n            control && control.getMouseDownHandler(e, target, control);\n        mouseDownHandler &&\n          mouseDownHandler.call(\n            control,\n            e,\n            this._currentTransform!,\n            pointer.x,\n            pointer.y,\n          );\n      }\n    }\n    //  we clear `_objectsToRender` in case of a change in order to repopulate it at rendering\n    //  run before firing the `down` event to give the dev a chance to populate it themselves\n    shouldRender && (this._objectsToRender = undefined);\n    this._handleEvent(e, 'down');\n    // we must renderAll so that we update the visuals\n    shouldRender && this.requestRenderAll();\n  }\n\n  /**\n   * reset cache form common information needed during event processing\n   * @private\n   */\n  _resetTransformEventData() {\n    this._target = undefined;\n    this._pointer = undefined;\n    this._absolutePointer = undefined;\n  }\n\n  /**\n   * Cache common information needed during event processing\n   * @private\n   * @param {Event} e Event object fired on event\n   */\n  _cacheTransformEventData(e: TPointerEvent) {\n    // reset in order to avoid stale caching\n    this._resetTransformEventData();\n    this._pointer = this.getViewportPoint(e);\n    this._absolutePointer = sendPointToPlane(\n      this._pointer,\n      undefined,\n      this.viewportTransform,\n    );\n    this._target = this._currentTransform\n      ? this._currentTransform.target\n      : this.findTarget(e);\n  }\n\n  /**\n   * Method that defines the actions when mouse is hovering the canvas.\n   * The currentTransform parameter will define whether the user is rotating/scaling/translating\n   * an image or neither of them (only hovering). A group selection is also possible and would cancel\n   * all any other type of action.\n   * In case of an image transformation only the top canvas will be rendered.\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  __onMouseMove(e: TPointerEvent) {\n    this._isClick = false;\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'move:before');\n\n    if (this.isDrawingMode) {\n      this._onMouseMoveInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    const groupSelector = this._groupSelector;\n\n    // We initially clicked in an empty area, so we draw a box for multiple selection\n    if (groupSelector) {\n      const pointer = this.getScenePoint(e);\n\n      groupSelector.deltaX = pointer.x - groupSelector.x;\n      groupSelector.deltaY = pointer.y - groupSelector.y;\n\n      this.renderTop();\n    } else if (!this._currentTransform) {\n      const target = this.findTarget(e);\n      this._setCursorFromEvent(e, target);\n      this._fireOverOutEvents(e, target);\n    } else {\n      this._transformObject(e);\n    }\n    this.textEditingManager.onMouseMove(e);\n    this._handleEvent(e, 'move');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Manage the mouseout, mouseover events for the fabric object on the canvas\n   * @param {Fabric.Object} target the target where the target from the mousemove event\n   * @param {Event} e Event object fired on mousemove\n   * @private\n   */\n  _fireOverOutEvents(e: TPointerEvent, target?: FabricObject) {\n    const _hoveredTarget = this._hoveredTarget,\n      _hoveredTargets = this._hoveredTargets,\n      targets = this.targets,\n      length = Math.max(_hoveredTargets.length, targets.length);\n\n    this.fireSyntheticInOutEvents('mouse', {\n      e,\n      target,\n      oldTarget: _hoveredTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      this.fireSyntheticInOutEvents('mouse', {\n        e,\n        target: targets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._hoveredTarget = target;\n    this._hoveredTargets = this.targets.concat();\n  }\n\n  /**\n   * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the onDrag event\n   * @param {Object} data Event object fired on dragover\n   * @private\n   */\n  _fireEnterLeaveEvents(target: FabricObject | undefined, data: DragEventData) {\n    const draggedoverTarget = this._draggedoverTarget,\n      _hoveredTargets = this._hoveredTargets,\n      targets = this.targets,\n      length = Math.max(_hoveredTargets.length, targets.length);\n\n    this.fireSyntheticInOutEvents('drag', {\n      ...data,\n      target,\n      oldTarget: draggedoverTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      this.fireSyntheticInOutEvents('drag', {\n        ...data,\n        target: targets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._draggedoverTarget = target;\n  }\n\n  /**\n   * Manage the synthetic in/out events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the supported events\n   * @param {Object} data Event object fired\n   * @param {Object} config configuration for the function to work\n   * @param {String} config.targetName property on the canvas where the old target is stored\n   * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n   * @param {String} config.evtOut name of the event to fire for out\n   * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n   * @param {String} config.evtIn name of the event to fire for in\n   * @private\n   */\n  fireSyntheticInOutEvents<T extends keyof TSyntheticEventContext>(\n    type: T,\n    {\n      target,\n      oldTarget,\n      fireCanvas,\n      e,\n      ...data\n    }: TSyntheticEventContext[T] & {\n      target?: FabricObject;\n      oldTarget?: FabricObject;\n      fireCanvas?: boolean;\n    },\n  ) {\n    const { targetIn, targetOut, canvasIn, canvasOut } =\n      syntheticEventConfig[type];\n    const targetChanged = oldTarget !== target;\n\n    if (oldTarget && targetChanged) {\n      const outOpt: CanvasEvents[typeof canvasOut] = {\n        ...data,\n        e,\n        target: oldTarget,\n        nextTarget: target,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasOut, outOpt);\n      oldTarget.fire(targetOut, outOpt);\n    }\n    if (target && targetChanged) {\n      const inOpt: CanvasEvents[typeof canvasIn] = {\n        ...data,\n        e,\n        target,\n        previousTarget: oldTarget,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasIn, inOpt);\n      target.fire(targetIn, inOpt);\n    }\n  }\n\n  /**\n   * Method that defines actions when an Event Mouse Wheel\n   * @param {Event} e Event object fired on mouseup\n   */\n  __onMouseWheel(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'wheel');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event fired on mousemove\n   */\n  _transformObject(e: TPointerEvent) {\n    const scenePoint = this.getScenePoint(e),\n      transform = this._currentTransform!,\n      target = transform.target,\n      //  transform pointer to target's containing coordinate plane\n      //  both pointer and object should agree on every point\n      localPointer = target.group\n        ? sendPointToPlane(\n            scenePoint,\n            undefined,\n            target.group.calcTransformMatrix(),\n          )\n        : scenePoint;\n    transform.shiftKey = e.shiftKey;\n    transform.altKey = !!this.centeredKey && e[this.centeredKey];\n\n    this._performTransformAction(e, transform, localPointer);\n    transform.actionPerformed && this.requestRenderAll();\n  }\n\n  /**\n   * @private\n   */\n  _performTransformAction(\n    e: TPointerEvent,\n    transform: Transform,\n    pointer: Point,\n  ) {\n    const { action, actionHandler, target } = transform;\n\n    const actionPerformed =\n      !!actionHandler && actionHandler(e, transform, pointer.x, pointer.y);\n    actionPerformed && target.setCoords();\n\n    // this object could be created from the function in the control handlers\n    if (action === 'drag' && actionPerformed) {\n      transform.target.isMoving = true;\n      this.setCursor(transform.target.moveCursor || this.moveCursor);\n    }\n    transform.actionPerformed = transform.actionPerformed || actionPerformed;\n  }\n\n  /**\n   * Sets the cursor depending on where the canvas is being hovered.\n   * Note: very buggy in Opera\n   * @param {Event} e Event object\n   * @param {Object} target Object that the mouse is hovering, if so.\n   */\n  _setCursorFromEvent(e: TPointerEvent, target?: FabricObject) {\n    if (!target) {\n      this.setCursor(this.defaultCursor);\n      return;\n    }\n    let hoverCursor = target.hoverCursor || this.hoverCursor;\n    const activeSelection = isActiveSelection(this._activeObject)\n        ? this._activeObject\n        : null,\n      // only show proper corner when group selection is not active\n      corner =\n        (!activeSelection || target.group !== activeSelection) &&\n        // here we call findTargetCorner always with undefined for the touch parameter.\n        // we assume that if you are using a cursor you do not need to interact with\n        // the bigger touch area.\n        target.findControl(this.getViewportPoint(e));\n\n    if (!corner) {\n      if ((target as Group).subTargetCheck) {\n        // hoverCursor should come from top-most subTarget,\n        // so we walk the array backwards\n        this.targets\n          .concat()\n          .reverse()\n          .map((_target) => {\n            hoverCursor = _target.hoverCursor || hoverCursor;\n          });\n      }\n      this.setCursor(hoverCursor);\n    } else {\n      const control = corner.control;\n      this.setCursor(control.cursorStyleHandler(e, control, target));\n    }\n  }\n\n  /**\n   * ## Handles multiple selection\n   * - toggles `target` selection (selects/deselects `target` if it isn't/is selected respectively)\n   * - sets the active object in case it is not set or in case there is a single active object left under active selection.\n   * ---\n   * - If the active object is the active selection we add/remove `target` from it\n   * - If not, add the active object and `target` to the active selection and make it the active object.\n   * @private\n   * @param {TPointerEvent} e Event object\n   * @param {FabricObject} target target of event to select/deselect\n   * @returns true if grouping occurred\n   */\n  protected handleMultiSelection(e: TPointerEvent, target?: FabricObject) {\n    const activeObject = this._activeObject;\n    const isAS = isActiveSelection(activeObject);\n    if (\n      // check if an active object exists on canvas and if the user is pressing the `selectionKey` while canvas supports multi selection.\n      !!activeObject &&\n      this._isSelectionKeyPressed(e) &&\n      this.selection &&\n      // on top of that the user also has to hit a target that is selectable.\n      !!target &&\n      target.selectable &&\n      // group target and active object only if they are different objects\n      // else we try to find a subtarget of `ActiveSelection`\n      (activeObject !== target || isAS) &&\n      //  make sure `activeObject` and `target` aren't ancestors of each other in case `activeObject` is not `ActiveSelection`\n      // if it is then we want to remove `target` from it\n      (isAS ||\n        (!target.isDescendantOf(activeObject) &&\n          !activeObject.isDescendantOf(target))) &&\n      //  target accepts selection\n      !target.onSelect({ e }) &&\n      // make sure we are not on top of a control\n      !activeObject.getActiveControl()\n    ) {\n      if (isAS) {\n        const prevActiveObjects = activeObject.getObjects();\n        if (target === activeObject) {\n          const pointer = this.getViewportPoint(e);\n          target =\n            // first search active objects for a target to remove\n            this.searchPossibleTargets(prevActiveObjects, pointer) ||\n            //  if not found, search under active selection for a target to add\n            // `prevActiveObjects` will be searched but we already know they will not be found\n            this.searchPossibleTargets(this._objects, pointer);\n          // if nothing is found bail out\n          if (!target || !target.selectable) {\n            return false;\n          }\n        }\n        if (target.group === activeObject) {\n          // `target` is part of active selection => remove it\n          activeObject.remove(target);\n          this._hoveredTarget = target;\n          this._hoveredTargets = [...this.targets];\n          // if after removing an object we are left with one only...\n          if (activeObject.size() === 1) {\n            // activate last remaining object\n            // deselecting the active selection will remove the remaining object from it\n            this._setActiveObject(activeObject.item(0), e);\n          }\n        } else {\n          // `target` isn't part of active selection => add it\n          activeObject.multiSelectAdd(target);\n          this._hoveredTarget = activeObject;\n          this._hoveredTargets = [...this.targets];\n        }\n        this._fireSelectionEvents(prevActiveObjects, e);\n      } else {\n        (activeObject as IText).isEditing &&\n          (activeObject as IText).exitEditing();\n        // add the active object and the target to the active selection and set it as the active object\n        const klass =\n          classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n        const newActiveSelection = new klass([], {\n          /**\n           * it is crucial to pass the canvas ref before calling {@link ActiveSelection#multiSelectAdd}\n           * since it uses {@link FabricObject#isInFrontOf} which relies on the canvas ref\n           */\n          canvas: this,\n        });\n        newActiveSelection.multiSelectAdd(activeObject, target);\n        this._hoveredTarget = newActiveSelection;\n        // ISSUE 4115: should we consider subTargets here?\n        // this._hoveredTargets = [];\n        // this._hoveredTargets = this.targets.concat();\n        this._setActiveObject(newActiveSelection, e);\n        this._fireSelectionEvents([activeObject], e);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ## Handles selection\n   * - selects objects that are contained in (and possibly intersecting) the selection bounding box\n   * - sets the active object\n   * ---\n   * runs on mouse up after a mouse move\n   */\n  protected handleSelection(e: TPointerEvent) {\n    if (!this.selection || !this._groupSelector) {\n      return false;\n    }\n    const { x, y, deltaX, deltaY } = this._groupSelector,\n      point1 = new Point(x, y),\n      point2 = point1.add(new Point(deltaX, deltaY)),\n      tl = point1.min(point2),\n      br = point1.max(point2),\n      size = br.subtract(tl);\n\n    const collectedObjects = this.collectObjects(\n      {\n        left: tl.x,\n        top: tl.y,\n        width: size.x,\n        height: size.y,\n      },\n      { includeIntersecting: !this.selectionFullyContained },\n    ) as FabricObject[];\n\n    const objects =\n      // though this method runs only after mouse move the pointer could do a mouse up on the same position as mouse down\n      // should it be handled as is?\n      point1.eq(point2)\n        ? collectedObjects[0]\n          ? [collectedObjects[0]]\n          : []\n        : collectedObjects.length > 1\n          ? collectedObjects\n              .filter((object) => !object.onSelect({ e }))\n              .reverse()\n          : // `setActiveObject` will call `onSelect(collectedObjects[0])` in this case\n            collectedObjects;\n\n    // set active object\n    if (objects.length === 1) {\n      // set as active object\n      this.setActiveObject(objects[0], e);\n    } else if (objects.length > 1) {\n      // add to active selection and make it the active object\n      const klass =\n        classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n      this.setActiveObject(new klass(objects, { canvas: this }), e);\n    }\n\n    // cleanup\n    this._groupSelector = null;\n    return true;\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  clear() {\n    this.textEditingManager.clear();\n    super.clear();\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  destroy() {\n    this.removeListeners();\n    this.textEditingManager.dispose();\n    super.destroy();\n  }\n}\n"],"names":["addEventOptions","passive","getEventPoints","canvas","e","viewportPoint","getViewportPoint","scenePoint","getScenePoint","pointer","absolutePointer","addListener","el","_len","arguments","length","args","Array","_key","addEventListener","removeListener","_len2","_key2","removeEventListener","syntheticEventConfig","mouse","in","out","targetIn","targetOut","canvasIn","canvasOut","drag","Canvas","SelectableCanvas","constructor","super","undefined","_defineProperty","this","TextEditingManager","forEach","eventHandler","bind","addOrRemove","_getEventPrefix","enablePointerEvents","functor","_eventjsFunctor","canvasElement","upperCanvasEl","eventTypePrefix","getWindowFromElement","_onResize","_onMouseDown","concat","_onMouseMove","_onMouseOut","_onMouseEnter","_onMouseWheel","_onContextMenu","_onDoubleClick","_onDragStart","_onDragEnd","_onDragOver","_onDragEnter","_onDragLeave","_onDrop","_onTouchStart","removeListeners","doc","getDocumentFromElement","_onMouseUp","_onTouchEnd","clearTimeout","_willAddMouseDown","__onMouseWheel","target","_hoveredTarget","shared","_objectSpread","fire","_hoveredTargets","nestedTarget","_currentTransform","findTarget","_isClick","activeObject","getActiveObject","onDragStart","_dragSource","options","_onDragProgress","stopEvent","_renderDragEffects","source","dirty","dropTarget","_dropTarget","clearContextTop","ctx","contextTop","save","transform","viewportTransform","renderDragSourceEffect","restore","renderDropTargetEffect","contextTopDirty","didDrop","dataTransfer","dropEffect","NONE","_activeObject","subTargets","targets","dragSource","_draggedoverTarget","findDragTargets","_searchPossibleTargets","_objects","eventType","canDrop","_fireEnterLeaveEvents","i","subTarget","_basicEventHandler","stopContextMenu","_cacheTransformEventData","_handleEvent","_resetTransformEventData","getPointerId","evt","changedTouches","identifier","pointerId","_isMainEvent","isPrimary","type","touches","mainTouchId","shouldPreventScrolling","allowTouchScrolling","currentActiveObject","__onMouseDown","isDrawingMode","_target","preventDefault","__onMouseUp","setTimeout","shouldStartDragging","__onMouseMove","calcOffset","_shouldRender","_this$_activeObject","isClick","button","fireMiddleClick","fireRightClick","_isCurrentlyDrawing","_onMouseUpInDrawingMode","corner","shouldRender","_finalizeCurrentTransform","actionPerformed","targetWasActive","handleSelection","found","findControl","isTouchEvent","key","control","selectable","activeOn","setActiveObject","mouseUpHandler","getMouseUpHandler","call","x","y","isMoving","originalControl","controls","originalMouseUpHandler","_setCursorFromEvent","_groupSelector","__corner","requestRenderAll","isEditing","renderTop","currentTarget","currentSubTargets","_onMouseDownInDrawingMode","discardActiveObject","freeDrawingBrush","onMouseDown","_onMouseMoveInDrawingMode","onMouseMove","setCursor","freeDrawingCursor","onMouseUp","grouped","handleMultiSelection","_shouldClearSelection","selection","p","deltaY","deltaX","alreadySelected","handle","_setupCurrentTransform","mouseDownHandler","getMouseDownHandler","_objectsToRender","_pointer","_absolutePointer","sendPointToPlane","groupSelector","_transformObject","_fireOverOutEvents","textEditingManager","Math","max","fireSyntheticInOutEvents","oldTarget","fireCanvas","data","draggedoverTarget","_ref","_objectWithoutProperties","_excluded","targetChanged","outOpt","nextTarget","inOpt","previousTarget","localPointer","group","calcTransformMatrix","shiftKey","altKey","centeredKey","_performTransformAction","action","actionHandler","setCoords","moveCursor","defaultCursor","hoverCursor","activeSelection","isActiveSelection","cursorStyleHandler","subTargetCheck","reverse","map","isAS","_isSelectionKeyPressed","isDescendantOf","onSelect","getActiveControl","prevActiveObjects","getObjects","searchPossibleTargets","remove","size","_setActiveObject","item","multiSelectAdd","_fireSelectionEvents","exitEditing","newActiveSelection","classRegistry","getClass","point1","Point","point2","add","tl","min","subtract","collectedObjects","collectObjects","left","top","width","height","includeIntersecting","selectionFullyContained","objects","eq","filter","object","klass","clear","destroy","dispose"],"mappings":"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"}