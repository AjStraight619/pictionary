import{defineProperty as e,objectWithoutProperties as t,objectSpread2 as r}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{getEnv as o}from"../env/index.min.mjs";import{isWebGLPipelineState as i}from"./utils.min.mjs";import{identityFragmentShader as a,vertexSource as n,highPsourceCode as s}from"./shaders/baseFilter.min.mjs";import{FabricError as c}from"../util/internals/console.min.mjs";import{createCanvasElementFor as u}from"../util/misc/dom.min.mjs";const h=["type"],m=["type"],p=new RegExp(s,"g");class g{get type(){return this.constructor.type}constructor(){let e=t(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},h);Object.assign(this,this.constructor.defaults,e)}getFragmentSource(){return a}getVertexSource(){return n}createProgram(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getFragmentSource(),r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.getVertexSource();const{WebGLProbe:{GLPrecision:i="highp"}}=o();"highp"!==i&&(t=t.replace(p,s.replace("highp",i)));const a=e.createShader(e.VERTEX_SHADER),n=e.createShader(e.FRAGMENT_SHADER),u=e.createProgram();if(!a||!n||!u)throw new c("Vertex, fragment shader or program creation error");if(e.shaderSource(a,r),e.compileShader(a),!e.getShaderParameter(a,e.COMPILE_STATUS))throw new c("Vertex shader compile error for ".concat(this.type,": ").concat(e.getShaderInfoLog(a)));if(e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw new c("Fragment shader compile error for ".concat(this.type,": ").concat(e.getShaderInfoLog(n)));if(e.attachShader(u,a),e.attachShader(u,n),e.linkProgram(u),!e.getProgramParameter(u,e.LINK_STATUS))throw new c('Shader link error for "'.concat(this.type,'" ').concat(e.getProgramInfoLog(u)));const h=this.getUniformLocations(e,u)||{};return h.uStepW=e.getUniformLocation(u,"uStepW"),h.uStepH=e.getUniformLocation(u,"uStepH"),{program:u,attributeLocations:this.getAttributeLocations(e,u),uniformLocations:h}}getAttributeLocations(e,t){return{aPosition:e.getAttribLocation(t,"aPosition")}}getUniformLocations(e,t){const r=this.constructor.uniformLocations,o={};for(let i=0;i<r.length;i++)o[r[i]]=e.getUniformLocation(t,r[i]);return o}sendAttributeData(e,t,r){const o=t.aPosition,i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i),e.enableVertexAttribArray(o),e.vertexAttribPointer(o,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW)}_setupFrameBuffer(e){const t=e.context;if(e.passes>1){const r=e.destinationWidth,o=e.destinationHeight;e.sourceWidth===r&&e.sourceHeight===o||(t.deleteTexture(e.targetTexture),e.targetTexture=e.filterBackend.createTexture(t,r,o)),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.targetTexture,0)}else t.bindFramebuffer(t.FRAMEBUFFER,null),t.finish()}_swapTextures(e){e.passes--,e.pass++;const t=e.targetTexture;e.targetTexture=e.sourceTexture,e.sourceTexture=t}isNeutralState(e){return!1}applyTo(e){i(e)?(this._setupFrameBuffer(e),this.applyToWebGL(e),this._swapTextures(e)):this.applyTo2d(e)}applyTo2d(e){}getCacheKey(){return this.type}retrieveShader(e){const t=this.getCacheKey();return e.programCache[t]||(e.programCache[t]=this.createProgram(e.context)),e.programCache[t]}applyToWebGL(e){const t=e.context,r=this.retrieveShader(e);0===e.pass&&e.originalTexture?t.bindTexture(t.TEXTURE_2D,e.originalTexture):t.bindTexture(t.TEXTURE_2D,e.sourceTexture),t.useProgram(r.program),this.sendAttributeData(t,r.attributeLocations,e.aPosition),t.uniform1f(r.uniformLocations.uStepW,1/e.sourceWidth),t.uniform1f(r.uniformLocations.uStepH,1/e.sourceHeight),this.sendUniformData(t,r.uniformLocations),t.viewport(0,0,e.destinationWidth,e.destinationHeight),t.drawArrays(t.TRIANGLE_STRIP,0,4)}bindAdditionalTexture(e,t,r){e.activeTexture(r),e.bindTexture(e.TEXTURE_2D,t),e.activeTexture(e.TEXTURE0)}unbindAdditionalTexture(e,t){e.activeTexture(t),e.bindTexture(e.TEXTURE_2D,null),e.activeTexture(e.TEXTURE0)}sendUniformData(e,t){}createHelpLayer(e){if(!e.helpLayer){const{sourceWidth:t,sourceHeight:r}=e,o=u({width:t,height:r});e.helpLayer=o}}toObject(){const e=Object.keys(this.constructor.defaults||{});return r({type:this.type},e.reduce(((e,t)=>(e[t]=this[t],e)),{}))}toJSON(){return this.toObject()}static async fromObject(e,r){return new this(t(e,m))}}e(g,"type","BaseFilter"),e(g,"uniformLocations",[]);export{g as BaseFilter};
//# sourceMappingURL=BaseFilter.min.mjs.map
